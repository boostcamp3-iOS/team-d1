//
//  StorageWorker.swift
//  BeBrav
//
//  Created by bumslap on 01/02/2019.
//  Copyright © 2019 bumslap. All rights reserved.
//

/// NetworkSeparator는 NetworkSeperatable을 구현한 구조체로서 dispatcher, requestMaker
/// 를 프로퍼티로 받아서 url을 조합하고 requst를 생성하여 dispatcher를 호출, 네트워킹을 실행합니다.

import UIKit

struct NetworkSeparator: NetworkSeperatable {
    
    let dispatcher: Dispatchable
    let requestMaker: RequestMakable
    
    init(dispatcher: Dispatchable, requestMaker: RequestMakable) {
        self.dispatcher = dispatcher
        self.requestMaker = requestMaker
    }
    
    func read(path: String,
              queries: [URLQueryItem]? = nil,
              completion: @escaping (Result<Data>, URLResponse?) -> Void) {
        guard var components = dispatcher.components else {
             completion(.failure(APIError.urlFailure), nil)
            return
        }
        components.queryItems = queries
        var url = components.url
        url?.appendPathComponent(path)
        //print(url?.asUrlWithoutEncoding())
        guard let request = requestMaker.makeRequest(url: url,
                                                     method: .get,
                                                     headers: [:],
                                                     body: nil) else {
            completion(.failure(APIError.requestFailed), nil)
            return
        }
        dispatcher.dispatch(request: request) { (result, response) in
            switch result {
            case .failure(let error):
                completion(.failure(error), nil)
            case .success(let data):
                completion(.success(data), response)
            }
        }
    }
    
    // POST, PUT, PATCH 만 유효함
    func write(path: String,
               data: Data,
               method: HTTPMethod,
               headers: [String: String],
               completion: @escaping (Result<Data>, URLResponse?) -> Void) {
        var url = dispatcher.components?.url
        url?.appendPathComponent(path)
        guard let request = requestMaker.makeRequest(url: url?.asUrlWithoutEncoding(),
                                                     method: method,
                                                     headers: ["Content-Type": MimeType.json.rawValue],
                                                     body: data) else {
            completion(.failure(APIError.requestFailed), nil)
            return
        }
        dispatcher.dispatch(request: request) { (result, response) in
            switch result {
            case .failure(let error):
                completion(.failure(error), nil)
            case .success(let data):
                completion(.success(data), response)
            }
        }
    }
    
    func delete(path: String,
                completion: @escaping (Result<URLResponse?>) -> Void) {
        var url = dispatcher.components?.url
        url?.appendPathComponent(path)
        guard let request = requestMaker.makeRequest(url: url?.asUrlWithoutEncoding(),
                                                     method: .delete,
                                                     headers: [:],
                                                     body: nil) else {
            completion(.failure(APIError.requestFailed))
            return
        }
        dispatcher.dispatch(request: request) { (result, response) in
            switch result {
            case .failure(let error):
                completion(.failure(error))
            case .success:
                completion(.success(response))
            }
        }
    }
}
